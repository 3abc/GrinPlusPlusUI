import ConnectionUtils from './ConnectionUtils';
import ConfigLoader from '../ConfigLoader';
import log from 'electron-log';
const fs = require('fs');
const archiver = require('archiver');
const cloudinary = require('cloudinary').v2;
const os = require('os');
import { version } from '../../../package.json';

const GRINPP_URL = 'https://api.grinplusplus.com';
const SUPPORT_PATH = '/bugreports/submit.php';

async function upload() {
    // set your env variable CLOUDINARY_URL or set the following configuration
    cloudinary.config({
        cloud_name: 'grinpp',
    });

    // File upload
    cloudinary.uploader.upload(__dirname + '/logs.zip', { resource_type: "raw" })
    .then(function(image) {
        log.info("** File Upload (Promise)");
        log.info("* public_id for the uploaded image is generated by Cloudinary's service.");
        log.info("* "+image.public_id);
        log.info("* "+image.url);

        if (global.mainWindow != null) {
            let result = new Object();
            result.success = true;
            global.mainWindow.webContents.send("Support::RequestSubmitted", result);
        }
    })
    .catch(function(err) {
        log.info("** File Upload (Promise)");
        if (err){
            let result = new Object();
            result.success = false;
            result.errorMessage = "Failed to upload. Error: " + error;
            log.error(err);
        }
    });
}

async function archiveLogs(name, email, description) {
    // create a file to stream archive data to.
    var output = fs.createWriteStream(__dirname + '/logs.zip');
    var archive = archiver('zip', {
        zlib: { level: 9 } // Sets the compression level.
    });

    // listen for all archive data to be written
    // 'close' event is fired only when a file descriptor is involved
    output.on('close', function() {
        log.info(archive.pointer() + ' total bytes');
        log.info('archiver has been finalized and the output file descriptor has closed.');
        upload();
    });

    // This event is fired when the data source is drained no matter what was the data source.
    // It is not part of this library but rather from the NodeJS Stream API.
    // @see: https://nodejs.org/api/stream.html#stream_event_end
    output.on('end', function() {
        log.info('Data has been drained');
    });

    // good practice to catch warnings (ie stat failures and other non-blocking errors)
    archive.on('warning', function(err) {
        if (err.code === 'ENOENT') {
            // log warning
        } else {
            // throw error
            throw err;
        }
    });

    // good practice to catch this error explicitly
    archive.on('error', function(err) {
        throw err;
    });

    // pipe archive data to the file
    archive.pipe(output);

    var today = new Date();
    var date = today.getFullYear() + '-' + (today.getMonth() + 1) + '-' + today.getDate();
    var time = today.getHours() + ":" + today.getMinutes() + ":" + today.getSeconds();
    var dateTime = date + ' ' + time;

    var userInfo = new Object();
    userInfo.name = name;
    userInfo.email = email;
    userInfo.description = description;
    userInfo.version = version;
    userInfo.dateTime = dateTime;
    userInfo.os = new Object();
    userInfo.os.platform = os.platform();
    userInfo.os.release = os.release();
    userInfo.os.arch = os.arch();
    userInfo.os.cpus = os.cpus();
    userInfo.os.totalmem = os.totalmem();

    archive.append(JSON.stringify(userInfo), { name: 'UserInfo.txt' });

    // append files from a sub-directory, putting its contents at the root of archive
    const logs_path = ConfigLoader.load().data_path + '/NODE/LOGS/';
    log.info("LOGS_PATH: " + logs_path);
    archive.directory(logs_path, false);

    // finalize the archive (ie we are done appending files but streams have to finish yet)
    // 'close', 'end' or 'finish' may be fired right after calling this method so register to them beforehand
    archive.finalize();
}

async function call(event, name, email, description) {
    log.info("Submitting support request");
    archiveLogs(name, email, description);
    /*const request = await ConnectionUtils.buildForeignRequest(GRINPP_URL, ForeignReceive.SUPPORT_PATH);
    if (request == null) {
        log.error("Failed to connect to bugreport service");
        event.returnValue = 'CantConnect';
        return;
    }
    
    request.on('response', (response) => {
        result["status_code"] = response.statusCode;

        var responseBody = "";
        response.on('data', (chunk) => {
            responseBody += chunk;
        });

        response.on('end', () => {
            result["body"] = responseBody;
            log.info("Bug report response: " + JSON.stringify(result));
            callback(result);
        });
    });
    request.on('error', (error) => {
        log.error("Error occurred when submitting bug report: " + error.message);
        result['raw_error'] = error.message;
        callback(result);
    });

    var requestBody = new object();
    requestBody.name = name;
    requestBody.email = email;
    requestBody.description = description;
    // TODO: Logs
    request.write(JSON.stringify(requestBody));
    request.end();*/

};

export default {call}